General TODO
============

Repo Maintenance
----------------
- Add license text to all source files.
- Update README.rst to actually explain this project.
- Add C++ include guards to all headers.

Build
-----
- Make it possible to specify e4__DISABLE_EXTENSIONS (or some other
  similar macro) to build the smallest version of e4 possible. This
  can include the exceptions word set and some words from the tools
  word set, but should include no core extensions or any functions
  that are only used by core extensions.
- Create a REPL build that uses an e4__DISABLE_EXTENSIONS build to
  ensure that e4 always builds correctly in this mode.
- Attempt to set up an AVR build (or some other 8-16 bit target build)
  to determine ROM size in that environment. (Preliminary size optimized
  builds seem to be at around 21K when targeting the ATMega328p).


Version 0.2
===========

Compilation
-----------
- Implement compiletime BRANCH0, BRANCH, AHEAD, etc.
- Add conditional structure words like IF, THEN, BEGIN, WHILE, LOOP,
  DO, etc.
- Add POSTPONE and IMMEDIATE words.
- Add compile time semantics to LITERAL. This may require actually
  adding another word, LIT, that takes the place of LITERAL's current
  non-standard behavior, since the current LITERAL needs to be
  executable in IMMEDIATE words. It would probably be worth renaming
  DLITERAL to DLIT or something along those lines as part of this
  change.
- Check for nested compilation everywhere relevant.
- Figure out how to implement RECURSE.
- Implement decompilation (ie. SEE). This only needs to work for words
  defined with execute_threaded to start; everything else can just
  display "builtin." The key way that this can be achieved is by
  placing a special sentinel value on the stack *after* the final EXIT
  call (this can be written by ;). The only other issue is how to
  handle words like THEN etc. This can be done with a little bit of
  look ahead state. If we know that IF is followed by BRANCH then some
  address, then we can simply keep track of what that address is and
  output THEN when we get to that address. We can use the stack for
  this. On function entry, track initial stack count. When IF is
  encountered, push THEN token (assuming we will need to do this with
  something other than THEN as well; we may not, in which case only
  an address is necessary) followed by an address. On each pass, before
  writing anything else, if stack depth is greater than initial depth,
  peek the top. If we're at that address, pop (once or twice, depending
  on whether a THEN token is needed) then display the appropriate word
  based on token. Aside from this, the only thing that needs to be done
  is look up a word in *reverse* based on its XT, and display that if
  it is present. If it isn't, we can assume it's a literal and just
  include it. Alternatively, we can understand LITERAL and other key
  words as look ahead words and not include them. Or, on the other
  hand, we could just naively display the internal representation and
  not worry about things like THEN and LITERAL. This is the easiest
  solution and is probably a perfectly reasonable place to start.

General Builtins
----------------
- Implement S", S\", and C". These words should use transient memory
  (possibly just HERE) during runtime, but during compile time they
  should compile a string directly into the definition as appropriate.
  This can be achieved by including some word STRING (similar to LIT)
  in the thread that pushes the subsequent counted string onto the
  stack as appropriate and advances the instruction pointer. The
  string should be compiled directly into the definition *with* end
  padding to align.
- Implement EVALUATE (builtin)
- Implement THROW and CATCH builtins.

General IO
----------
- Implement pictured numeric output.

Kernel
-----
- Add support for double cell numbers (including arithmetic etc.).
- Update words meant to support double width numbers that are currently
  implemented without any such support. This includes >NUMBER.
- Add more two's complement utility macros as needed and use them where
  appropriate.
- Implement signed modulo and other single width math operators.
- Handle dictionary overflows and other overflows.
- Consider improving exception printing (ie. printing exception name
  along with number).

Testing
-------
- Figure out some way to cover return stack corruption in tests.
- Cover user IO errors in tests (ie. user provided IO handler returns
  non-zero).


Version 0.9
===========

(things to have done prior to 1.0)

Documentation
-------------
- Document all implementation-defined behavior as per Forth 2012 4.1.1.
- Document all ambiguous condition handling as per Forth 2012 4.1.2.
- Provide other system documentation as per by Forth 2012 4.1.3.

General Builtins
----------------
- Consider implementing the entire Programming-Tools word set.
- Determine whether CR should actually output \r\n. If it should,
  ensure that \r\n is used instead of \n in all places where \n is
  currently in use.

Testing
-------
- Add tests for every builtin word as prescribed by the standard.


Transfer Station
================

(won't do lists; cleared after each release)
