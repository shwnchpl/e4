General TODO
============

Repo Maintenance
----------------
- Add license text to all source files.
- Update README.rst to actually explain this project.
- Add C++ include guards to all headers.

Build
-----
- Attempt to set up an AVR build (or some other 8-16 bit target build)
  to determine ROM size in that environment. (Preliminary size optimized
  builds seem to be at around 21K when targeting the ATMega328p).


Version 0.2
===========

Build
-----
- [DONE] Add preprocessor controls for disabling various wordsets to
  produce a minimal build.
- [DONE] Create a special Make target that tests building various
  build configurations to ensure they call build properly and there
  are no erroneous interdependencies between wordsets.
- Fix as many pedantic errors as possible.

Compilation
-----------
- [DONE] Implement compiletime BRANCH and BRANCH0 builtins.
- [DONE] Add conditional structure words like IF, ELSE, and THEN.
- [DONE] Implement RECURSE. This is easy to do since RECURSE only needs
  to compile in the address of the XT of the current dictionary entry.
- [DONE] Implement  BEGIN, UNTIL, AGAIN, WHILE, and REPEAT.
- [DONE] Implement DO, ?DO, LOOP, LOOP+, and LEAVE.
- [DONE] Implement I, J, and UNLOOP.
- [DONE] Rename LITERAL to LIT_CELL and DLITERAL to LIT_DOES.
- [DONE] Implement LITERAL.
- [DONE] Implement [ and ].
- [DONE] Implement MARKER.
- [DONE] Implement LIT_CSTR and LIT_STR.
- [DONE] Add POSTPONE and IMMEDIATE words.
- [DONE] Add restruct keyword.
- [DONE] Check for nested compilation everywhere relevant.

General Builtins
----------------
- [DONE] Implement core builtin logic/comparison words: = < > 0< 0= AND
  INVERT NEGATE OR XOR.
- [DONE] Implement *.
- [DONE] Implement /, MOD, /MOD.
- [DONE] Implement U<.
- [DONE] Add macro handling for implementing some builtins as threaded
  code and refactor those builtins to be  implemented in threaded code.
- [DONE] Throw division by zero exceptions where necessary.
- [DONE] Refactor builtin XT table to not include unused data field.
- [DONE] Implement core extension logic/comparison words: 0<> 0> <> U>.
- [DONE] Implement ( and \.
- [DONE] Implement 1+, 1-, 2*, 2/, LSHIFT, and RSHIFT.
- [DONE] Implement CELL+, CHAR+, and CHARS.
- [DONE] Implement ALIGN and ALIGNED.
- [DONE] Implement C@, C,, and C!.
- [DONE] Implement >R, R>, R@.
- [DONE] Implement MIN and MAX.
- [DONE] Implement HEX and DECIMAL.
- [DONE] Add support for "pun" builtins (builtins that simply execute
  another builtin, potentially with different flags). Update the BEGIN
  implementation in this way (as compiletime immediate HERE).
- [DONE] Implement NIP and PICK.
- [DONE] Implement 2DUP, 2DROP, 2OVER, 2SWAP.
- [DONE] Implement 2!, 2@, and +!.
- [DONE] Implement 2>R, 2R>, and 2R@.
- [DONE] Use 2DUP, 2DROP, etc. where appropriate (in builtin
  definitons).
- [DONE] Implement COUNT and TYPE.
- [DONE] Implement C", S", and ." (compile time semantics only).
- [DONE] Implement C", S", and ." compile time semantics in terms of
  e4__io_parse.
- [DONE] Implement S\" compile time semantics.
- [DONE] Implement the DUMP builtin.
- [DONE] Implement .( and ." run time semantics.
- [DONE] Make IMMEDIATE/COMPONLY flag specification order consistent in
  builtin declarations.
- [DONE] Implement ABS.
- [DONE] Implement FILL, ERASE, and MOVE builtins.
- [DONE] Implement BUFFER: builtin.
- [DONE] Implement UNUSED builtin.
- [DONE] Implement EVALUATE and SOURCE-ID builtins.
- [DONE] Implement the KEY builtin.
- [DONE] Implement THROW and CATCH builtins.
- Implement ?DUP, CHAR, [CHAR], SPACE, and SPACES.

Kernel
------
- [DONE] Throw exceptions in the event of return stack corruption.
- [DONE] Ensure tr0 always has a coherent value, especially across
  exceptions. To make tr0 always have a coherent value, it will be
  necessary to at least set it to r0 on task initialization and preserve
  its value across exceptions.
- [DONE] Add asserts that execute_tuple and execute_token field order
  lines up correctly.
- [DONE] Ensure memmove is always called with size_t, not e4__usize.
  It's possible (although unlikely) that these types may not implicitly
  convert between one another without generating a warning.
- [DONE] Print exception description along with number.
- [DONE] Thunk into e4__builtin_exec and return error code.
- [DONE] Thunk into exceptions when evaluating REFILL in QUIT. Cover
  this in tests.

REPL
----
- [DONE] Add tab-completion to the repl.
- [DONE] Simply return e4__E_BYE exception when EOF is encountered.
- Implement a custom signal handler or custom signal handlers so that
  it's possible to handle SIGINT and throw the appropriate exception.
  If an exception cannot be thrown, in SIGNIT, the fallback should be
  to simply call exit with an appropriate exit status (OK?) directly.
  This is all possible because it is safe to longjmp out of signal
  handlers as long as they aren't nested (ie. a signal handler invoked
  because of code that was executing in another signal handler). It
  should be possible to ensure that will never happen and stay within
  the realm of defined behavior while taking advantage of the existing
  exception semantic.
  Signal handlers will need to take appropriate action to keep libedit
  happy as well (in particular, it is necessary to call el_resize upon
  receipt of SIGWINCH).
- Catch SIGSEV and raise an exception if possible (and call exit if
  not).

Testing
-------
- [DONE] Figure out some way to cover return stack corruption in tests.
- [DONE] Cover the DUMP builtin, the e4__io_dump API, and the
  e4__mem_dump utility.
- [DONE] Cover user IO errors in tests (ie. user provided IO handler
  returns non-zero or IO handler is missing).
- [DONE] Cover return stack underflow in the event of a direct call to
  e4__execute_ret whether exceptions are enabled or not.
- [DONE] Add tests to ensure that return stack coherence tracking(with
  tr0) behaves correctly when exceptions are disabled.
- [DONE] Cover tr0 coherence (with exceptions enabled) in tests. This
  can be done using THROW and CATCH along with r> and >r.


Version 0.3
===========

Build
-----
- Split system required words and optional system specific extension
  words into different modules (SYSTEM and SYSTEM-EXIT?).

Compilation
-----------
- Add conditional structure words CASE OF ENDCASE ENDOF etc.
- Implement decompilation (ie. SEE). This only needs to work for words
  defined with execute_threaded to start; everything else can just
  display "builtin." The key way that this can be achieved is by
  placing a special sentinel value on the stack *after* the final EXIT
  call (this can be written by ;). The only other issue is how to
  handle words like THEN etc. This can be done with a little bit of
  look ahead state. If we know that IF is followed by BRANCH then some
  address, then we can simply keep track of what that address is and
  output THEN when we get to that address. We can use the stack for
  this. On function entry, track initial stack count. When IF is
  encountered, push THEN token (assuming we will need to do this with
  something other than THEN as well; we may not, in which case only
  an address is necessary) followed by an address. On each pass, before
  writing anything else, if stack depth is greater than initial depth,
  peek the top. If we're at that address, pop (once or twice, depending
  on whether a THEN token is needed) then display the appropriate word
  based on token. Aside from this, the only thing that needs to be done
  is look up a word in *reverse* based on its XT, and display that if
  it is present. If it isn't, we can assume it's a literal and just
  include it. Alternatively, we can understand LIT_CELL and other key
  words as look ahead words and not include them. Or, on the other
  hand, we could just naively display the internal representation and
  not worry about things like THEN and LIT_CELL. This is the easiest
  solution and is probably a perfectly reasonable place to start.

General Builtins
----------------
- Implement the PAGE builtin using escape sequences. The following
  implementation works:
        : page s\" \e[2J\e[0;0H" type ;
- Implement the AT-XY builtin using pictured numeric output and escape
  the ASCII cursor position escape sequence \033[<L>;<C>H. The
  following implementation works:
        : at-xy
            s>d rot s>d
            <#
                'H' hold
                #s 2drop
                ';' hold
                #s
                '[' hold
                27 hold
            #> type
            ;
- Consider adding _NF variants to USERVAR declaration macros, defining
  e4__UV_BEGIN, and simply defining BEGIN as its own uservar rather
  than in terms of HERE using PUN macros. Consider also removing pun
  macros.
- Implement the ENVIRONMENT? builtin.

General IO
----------
- Implement pictured numeric output.

Kernel
------
- Add support for double cell numbers (including arithmetic, the text
  interpreter extension for numbers of the format XXXX. as outlined in
  section 8.3.1 of the standard, etc.).
- Update words meant to support double width numbers that are currently
  implemented without any such support. This includes >NUMBER.
- Add more two's complement utility macros as needed and use them where
  appropriate.
- Handle dictionary overflows and other overflows.
- Improve exception printing implementation and other hackish printing
  implementations (such as the . builtin etc.) by using pictured
  numeric output instead?
- Consider whether it might be possible to wrap the main quit loop in
  some kind of exception context (somehow?) to get around the race
  conditon created by using multiple different exception contexts
  within that loop. It's unclear exactly how this would look since
  the quit loop relies on certain exceptions percolating all the way
  up, so for it to itself run in an exception context some considerable
  refactoring might be necessary. This is important because on embedded
  systems, or even in a repl where a signal can be caught, it may be
  desirable to throw an exception when quit, as currently implemented,
  is not in an interrupt context. This *may* not be an issue (failure
  to actually throw is always something an API client can work around),
  but it probably isn't entirely desirable.

REPL
----
- Source ~/.e4-editrc to allow for e4 specific input overrides. For
  example, tab completion on tab could be disabled by macro binding
  the tab key to two or four spaces.


Version 0.9
===========

(things to have done prior to 1.0)

Compilation
-----------
- Implement AHEAD?
- Implement some system +LOOP word that executes LOOP/LOOP+ execution
  semantics to save RAM space? This can be done using the same
  return stack manipulation techniques used for words like R@ and J.

Documentation
-------------
- Document all implementation-defined behavior as per Forth 2012 4.1.1.
- Document all ambiguous condition handling as per Forth 2012 4.1.2.
- Provide other system documentation as per by Forth 2012 4.1.3.
- Document the fact that excluding the exception wordlist does not
  actually disable exceptions. Even with the exceptions wordlist
  excluded, exceptions are still used internally; it's just that the
  CATCH and THROW builtin words are not available.

Kernel
------
- Consider adding optional IO handlers to allow for supporting the
  FILE wordset. If this is done, also add FILE related builtins
  and the appropriate hooks to the REPL.
- Consider adding builtin POSIX handlers for file IO that can be
  enabled/disabled (off by default) at compile time.
- Consider making return stack coherence tracking optional at compile-
  time to allow for RAM savings.
- Throw address alignment exceptions (-23) where appropriate? On one
  hand, this could be a nice way to avoid performance issues. On the
  other hand, on some systems unaligned access is fine.
- Consider adding an e4__stack_rclear API and using where appropriate.
- Consider adding some kind of NO_INTERPRET or INTERNAL flag for words
  that can never be used correctly (whether interpreting or compiling)
  from a non-system context (for instance, BRANCH, BRANCH0, and LIT_*
  as currently implemented). Making words that need to have some effect
  compile only and immediate then checking whether compiling as a hack
  is not sufficient because those words may be called from a word
  marked IMMEDIATE. Alternatively, some other word to bake in addresses
  (such as [LIT]), which risky, could be handy. With such a word, it
  would be possible to write things like : SKIP BRANCH [LIT] 1 ; (which
  itself is also more risky than useful, although that doesn't mean
  there could be no reasonable application). As an alternative, these
  words could be given some kind of "hidden" flag so that it isn't
  possible to look them up.

General Builtins
----------------
- Consider implementing the entire Programming-Tools word set.
- Determine whether CR should actually output \r\n. If it should,
  ensure that \r\n is used instead of \n in all places where \n is
  currently in use.
- Implement S", S\", and C" run time semantics. These words should
  use the designated transient memory buffers as necessary during
  runtime. Last offset can be tracked, modulo style, and only spill
  over if a buffer is too long to fit. This is needed for the FILE
  word set, but is probably expressly non-desirable for minimal
  builds since being standards complient requires reserving 160 bytes
  of memory minimum and it is not specified that this memoery can be
  overrun by dictionary changes, meaning it is expected to be
  dedicated. As such, this should almost certianly live behind some
  compiler flag (perhaps the file word set compiler flag?) and it is
  decidedly not a high priority.

Testing
-------
- Add tests for every builtin word as prescribed by the standard.


Transfer Station
================

(won't do lists; cleared after each release)

Kernel
------
- Add more two's complement utility macros as needed and use them where
  appropriate.
    -- There doesn't appear to be any need for more two's complement
       macros.
- Refactor code that takes the size of the execute_token structure and
  subtracts the size of the data field when allocating to take the size
  of an execute_tuple structure instead?
    -- No real reason to do this.
- Add e4__task_interrupt API. This API can be called from a signal
  handler or an ISR (as long as the e4__task is *known* not to be
  running) and it sets a flag in the task that will throw an
  e4__E_INTERRUPTED exception from threaded_execute as soon as
  possible. This can be used by REPLs as a way of handling SIGINT
  etc. Once this is implemented, test it out in the REPL. Consider
  how to implement this so that it doesn't behave oddly when waiting
  for input. One idea is that execution depth could be counted in
  e4__thread_execute (possibly nice to have for other reasons as
  well) and the flag could be set only in cases when that value
  is non-zero, although this would have the unfortunate side effect
  of needing to track yet another thing across exceptions.
    -- As it turns out, this isn't actually needed for anything, and
       it's not the cleanest thing, so avoiding it is the best course
       of action.

Testing
-------
- Cover the fact that ip is set to NULL after an exception.
    -- This is an implementation detail. If everything "works," it
       doesn't really matter what IP is set to after an exception.
       It just ends up getting reset at the relevant execute_ret
       call or becoming irrelevant because evaluation/execution is
       complete anyhow.
