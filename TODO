General TODO
============

Repo Maintenance
----------------
- Add license text to all source files.
- Update README.rst to actually explain this project.
- Add C++ include guards to all headers.

Build
-----
- Add an amalgamated source target using amal.rb.
- Create a repl build that uses the amalgamated source target.
- Make it possible to disable core extensions for an even smaller build.
- Attempt to set up an AVR build (or some other 8-16 bit target build)
  to determine ROM size in that environment.

Documentation
-------------
- Document all implementation-defined behavior as per Forth 2012 4.1.1.
- Document all ambiguous condition handling as per Forth 2012 4.1.2.
- Provide other system documentation as per by Forth 2012 4.1.3.


Version 0.1
===========

Parsing/Text Execution
----------------------
- [DONE] Implement WORD (builtin)
- [DONE] Make existing LOOKUP C API case insensitive?
- [DONE] Fix WORD implementation to correctly advance >IN and also
  to pay attention to count.
- [DONE] Implement >NUMBER (builtin/C API)
- [DONE] Reverse mem_parse API to match mem_number API semantics.
- Create e4__io_refill function and use where appropriate rather than
  calling builtin directly.
- Determine if KEY should be writing to TIB.

General Builtins
----------------
- [DONE] Implement basic static manipulation words CLEAR, DEPTH, DROP,
  DUP, OVER, ROT, ROLL, SWAP, and TUCK.
- [DONE] Implement REFILL.
- [DONE] Implement FORGET. It should stop looking once it hits builtin
  words.
- [DONE] Implement CR.
- [DONE] Implement + and -.
- [DONE] Implement ..
- [DONE] Add appropriate asserts to all existing builtins.
- [DONE] Implement WORDS.
- [DONE] Add the ability to add flags to builtins defined with the
  macros in core/builtin.c.
- [DONE] Add compile-time flags to appropriate builtins in
  core/builtin.c.
- [DONE] Implement @ and !.
- [DONE] Implement HERE, CELLS, and ALLOT.
- [DONE] Add mechanism for builtin constants (such as BL, etc.).
- [DONE] Add mechanism for uservar definitions.
- [DONE] Refactor HERE to be a uservar.
- [DONE] Add BASE and PAD builtins.
- [DONE] Add CREATE, VARIABLE, CONSTANT, and , builtins.
- Add VALUE and TO builtins. VALUE and CONSTANT should differ in that
  CONSTANT should have some flag preventing update with TO.
- Implement simple IO builtins U. and EMIT.
- Implement ' (LOOKUP builtin; should be case insensitive)
- Implement EXECUTE (builtin).
- Fix ABORT implementation.

Kernel
------
- [DONE] Move entire builtin dictionary into ROM.
- [DONE] Get rid of fields like POB and SQ and just use HERE instead
  to save space. The dedicated static PAD space can stay.
- [DONE] Create custom integer types that are the same width as e4__cell
  and use these where appropriate (as opposed to unsigned long etc.).
- [DONE] Creating custom integer types for u8 and bool as well rather
  than simply using char.
- [DONE] Implement numeric signed division.
- [DONE] Implement preliminary evaluate utility function.
- [DONE] Implement exceptions using setjmp/longjmp.
- [DONE] Implement QUIT using exceptions etc.
- [DONE] Figure out stack underflow checking for builtins etc.
- [DONE] Implement RET as a utility function and cleanup RET builtin
  definition.
- [DONE] Prevent builtins with the COMPONLY flag set from being
  interpreted.
- [DONE] Cleanup evaluate and evaluate_quit implementation, removing
  unnecessary parameters.
- [DONE] Implement _constant, _variable, and _uservar code handlers.
- Implement _thunk code handler (for DOES>).
- Always use size or sz as name to indicate size in API parameters.

General IO
----------
- [DONE] Implement two's complement integer formatting.

Compilation
-----------
- [DONE] Refactor dict API into mem_dict API.
- [DONE] Add true dict API that allows creating a new dict entry by
  acting on the task struct and updating HERE and other fields
  appropriately.
- [DONE] Implement simple : compilation.
- [DONE] Check for stack balance at end of compilation. If stack is not
  in the same position as it was at the start of compilation, throw the
  appropriate exception and reject the definition.
- Implement DOES>.

Testing
-------
- [DONE] Create a test harness.
- [DONE] Finalize test harness organization.
- [DONE] Migrate digit formatting tests.
- [DONE] Migrate basic two's complement tests.
- [DONE] Migrate two's complement signed division tests.
- [DONE] Migrate numeric parsing tests.
- [DONE] Migrate builtin word parsing tests.
- [DONE] Migrate stack API tests.
- [DONE] Migrate >NUMBER builtin tests.
- [DONE] Migrate builtin WORD tests.
- [DONE] Migrate dict entry creation tests.
- [DONE] Add exception tests (see uncommitted diff).
- Add tests for every builtin word as prescribed by the standard.
- Figure out some way to cover WORDS in tests.
- Figure out some way to cover return stack corruption in tests.

REPL
----
- [DONE] Create actual simple REPL using libedit or some other utility.
- Figure out having \n user input print a space rather than newline
  while maintaining all other \n semantics using libedit (or otherwise
  abandon this goal and delete the commented out code in repl/main.c).


Version 0.2
===========

Compilation
-----------
- Implement compiletime BRANCH0, BRANCH, AHEAD, etc.
- Add conditional structure words like IF, THEN, BEGIN, WHILE, LOOP,
  DO, etc.
- Add compile time semantics to LITERAL.
- Figure out how to implement RECURSE.
- Implement decompilation (ie. SEE). This only needs to work for words
  defined with execute_threaded to start; everything else can just
  display "builtin." The key way that this can be achieved is by
  placing a special sentinel value on the stack *after* the final EXIT
  call (this can be written by ;). The only other issue is how to
  handle words like THEN etc. This can be done with a little bit of
  look ahead state. If we know that IF is followed by BRANCH then some
  address, then we can simply keep track of what that address is and
  output THEN when we get to that address. We can use the stack for
  this. On function entry, track initial stack count. When IF is
  encountered, push THEN token (assuming we will need to do this with
  something other than THEN as well; we may not, in which case only
  an address is necessary) followed by an address. On each pass, before
  writing anything else, if stack depth is greater than initial depth,
  peek the top. If we're at that address, pop (once or twice, depending
  on whether a THEN token is needed) then display the appropriate word
  based on token. Aside from this, the only thing that needs to be done
  is look up a word in *reverse* based on its XT, and display that if
  it is present. If it isn't, we can assume it's a literal and just
  include it. Alternatively, we can understand LITERAL and other key
  words as look ahead words and not include them. Or, on the other
  hand, we could just naively display the internal representation and
  not worry about things like THEN and LITERAL. This is the easiest
  solution and is probably a perfectly reasonable place to start.

Kernel
-----
- Add support for double cell numbers (including arithmetic etc.).
- Update words meant to support double width numbers that are currently
  implemented without any such support. This includes >NUMBER.
- Add more two's complement utility macros as needed and use them where
  appropriate.
- Implement signed modulo and other single width math operators.
- Handle dictionary overflows and other overflows.

General IO
----------
- Implement pictured numeric output.

General Builtins
----------------
- Implement S", S\", and C". These words should use transient memory
  (possibly just HERE) during runtime, but during compile time they
  should compile a string directly into the definition as appropriate.
  This can be achieved by including some word STRING (similar to LIT)
  in the thread that pushes the subsequent counted string onto the
  stack as appropriate and advances the instruction pointer. The
  string should be compiled directly into the definition *with* end
  padding to align.
- Implement EVALUATE (builtin)
- Consider implementing the Programming-Tools word set.
- Determine whether CR should actually output \r\n. If it should,
  ensure that \r\n is used instead of \n in all places where \n is
  currently in use.
